{"version":3,"file":"static/js/8183.31206826.chunk.js","mappings":"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","sources":["../node_modules/@ethersproject/providers/src.ts/alchemy-provider.ts","../node_modules/@ethersproject/providers/src.ts/ankr-provider.ts","../node_modules/@ethersproject/providers/src.ts/cloudflare-provider.ts","../node_modules/@ethersproject/providers/src.ts/etherscan-provider.ts","../node_modules/@ethersproject/providers/src.ts/fallback-provider.ts","../node_modules/@ethersproject/providers/src.ts/browser-ipc-provider.ts","../node_modules/@ethersproject/providers/src.ts/infura-provider.ts","../node_modules/@ethersproject/providers/src.ts/json-rpc-batch-provider.ts","../node_modules/@ethersproject/providers/src.ts/nodesmith-provider.ts","../node_modules/@ethersproject/providers/src.ts/pocket-provider.ts","../node_modules/@ethersproject/providers/src.ts/index.ts"],"sourcesContent":["\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { CommunityResourcable, showThrottleMessage } from \"./formatter\";\nimport { WebSocketProvider } from \"./websocket-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n// This key was provided to ethers.js by Alchemy to be used by the\n// default provider, but it is recommended that for your own\n// production environments, that you acquire your own API key at:\n//   https://dashboard.alchemyapi.io\n\nconst defaultApiKey = \"_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC\"\n\nexport class AlchemyWebSocketProvider extends WebSocketProvider implements CommunityResourcable {\n    readonly apiKey: string;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        const provider = new AlchemyProvider(network, apiKey);\n\n        const url = provider.connection.url.replace(/^http/i, \"ws\")\n                                           .replace(\".alchemyapi.\", \".ws.alchemyapi.\");\n\n        super(url, provider.network);\n        defineReadOnly(this, \"apiKey\", provider.apiKey);\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n\nexport class AlchemyProvider extends UrlJsonRpcProvider {\n\n    static getWebSocketProvider(network?: Networkish, apiKey?: any): AlchemyWebSocketProvider {\n        return new AlchemyWebSocketProvider(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey == null) { return defaultApiKey; }\n        if (apiKey && typeof(apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey;\n    }\n\n    static getUrl(network: Network, apiKey: string): ConnectionInfo {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"eth-mainnet.alchemyapi.io/v2/\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.alchemyapi.io/v2/\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.alchemyapi.io/v2/\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.alchemyapi.io/v2/\";\n                break;\n            case \"kovan\":\n                host = \"eth-kovan.alchemyapi.io/v2/\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum\":\n                host = \"arb-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"arbitrum-rinkeby\":\n                host = \"arb-rinkeby.g.alchemy.com/v2/\";\n                break;\n            case \"optimism\":\n                host = \"opt-mainnet.g.alchemy.com/v2/\";\n                break;\n            case \"optimism-kovan\":\n                host = \"opt-kovan.g.alchemy.com/v2/\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + apiKey),\n            throttleCallback: (attempt: number, url: string) => {\n                if (apiKey === defaultApiKey) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n","\nimport { Network } from \"@ethersproject/networks\";\n\nimport { showThrottleMessage } from \"./formatter\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nimport type { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n\nconst defaultApiKey = \"9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972\";\n\nfunction getHost(name: string): string {\n    switch (name) {\n        case \"homestead\":\n            return \"rpc.ankr.com/eth/\";\n        case \"ropsten\":\n            return \"rpc.ankr.com/eth_ropsten/\";\n        case \"rinkeby\":\n            return \"rpc.ankr.com/eth_rinkeby/\";\n        case \"goerli\":\n            return \"rpc.ankr.com/eth_goerli/\";\n\n        case \"matic\":\n            return \"rpc.ankr.com/polygon/\";\n\n        case \"arbitrum\":\n            return \"rpc.ankr.com/arbitrum/\";\n    }\n    return logger.throwArgumentError(\"unsupported network\", \"name\", name);\n}\n\nexport class AnkrProvider extends UrlJsonRpcProvider {\n    readonly apiKey: string;\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey == null) { return defaultApiKey; }\n        return apiKey;\n    }\n\n    static getUrl(network: Network, apiKey: any): ConnectionInfo {\n        if (apiKey == null) { apiKey = defaultApiKey; }\n        const connection: ConnectionInfo = {\n            allowGzip: true,\n            url: (\"https:/\\/\" + getHost(network.name) + apiKey),\n            throttleCallback: (attempt: number, url: string) => {\n                if (apiKey.apiKey === defaultApiKey) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret\n        }\n\n        return connection;\n    }\n}\n","\"use strict\";\n\nimport { Network } from \"@ethersproject/networks\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nexport class CloudflareProvider extends UrlJsonRpcProvider {\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey != null) {\n            logger.throwArgumentError(\"apiKey not supported for cloudflare\", \"apiKey\", apiKey);\n        }\n        return null;\n    }\n\n    static getUrl(network: Network, apiKey?: any): string {\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://cloudflare-eth.com/\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return host;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n        // The Cloudflare provider does not support eth_blockNumber,\n        // so we get the latest block and pull it from that\n        if (method === \"getBlockNumber\") {\n            const block = await super.perform(\"getBlock\", { blockTag: \"latest\" });\n            return block.number;\n        }\n\n        return super.perform(method, params);\n    }\n}\n","\"use strict\";\n\nimport { BlockTag, TransactionRequest, TransactionResponse } from \"@ethersproject/abstract-provider\";\nimport { hexlify, hexValue, isHexString } from \"@ethersproject/bytes\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly } from \"@ethersproject/properties\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { ConnectionInfo, fetchJson } from \"@ethersproject/web\";\n\nimport { showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { BaseProvider } from \"./base-provider\";\n\n\n// The transaction has already been sanitized by the calls in Provider\nfunction getTransactionPostData(transaction: TransactionRequest): Record<string, string> {\n    const result: Record<string, string> = { };\n    for (let key in transaction) {\n        if ((<any>transaction)[key] == null) { continue; }\n        let value = (<any>transaction)[key];\n        if (key === \"type\" && value === 0) { continue; }\n\n        // Quantity-types require no leading zero, unless 0\n        if ((<any>{ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true })[key]) {\n            value = hexValue(hexlify(value));\n        } else if (key === \"accessList\") {\n            value = \"[\" + accessListify(value).map((set) => {\n                return `{address:\"${ set.address }\",storageKeys:[\"${ set.storageKeys.join('\",\"') }\"]}`;\n            }).join(\",\") + \"]\";\n        } else {\n            value = hexlify(value);\n        }\n        result[key] = value;\n    }\n    return result;\n}\n\nfunction getResult(result: { status?: number, message?: string, result?: any }): any {\n    // getLogs, getHistory have weird success responses\n    if (result.status == 0 && (result.message === \"No records found\" || result.message === \"No transactions found\")) {\n        return result.result;\n    }\n\n    if (result.status != 1 || result.message != \"OK\") {\n        const error: any = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        if ((result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n            error.throttleRetry = true;\n        }\n        throw error;\n    }\n\n    return result.result;\n}\n\nfunction getJsonResult(result: { jsonrpc: string, result?: any, error?: { code?: number, data?: any, message?: string} } ): any {\n    // This response indicates we are being throttled\n    if (result && (<any>result).status == 0 && (<any>result).message == \"NOTOK\" && (result.result || \"\").toLowerCase().indexOf(\"rate limit\") >= 0) {\n        const error: any = new Error(\"throttled response\");\n        error.result = JSON.stringify(result);\n        error.throttleRetry = true;\n        throw error;\n    }\n\n    if (result.jsonrpc != \"2.0\") {\n        // @TODO: not any\n        const error: any = new Error(\"invalid response\");\n        error.result = JSON.stringify(result);\n        throw error;\n    }\n\n    if (result.error) {\n        // @TODO: not any\n        const error: any = new Error(result.error.message || \"unknown error\");\n        if (result.error.code) { error.code = result.error.code; }\n        if (result.error.data) { error.data = result.error.data; }\n        throw error;\n    }\n\n    return result.result;\n}\n\n// The blockTag was normalized as a string by the Provider pre-perform operations\nfunction checkLogTag(blockTag: string): number | \"latest\" {\n    if (blockTag === \"pending\") { throw new Error(\"pending not supported\"); }\n    if (blockTag === \"latest\") { return blockTag; }\n\n    return parseInt(blockTag.substring(2), 16);\n}\n\n\nconst defaultApiKey = \"9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB\";\n\nfunction checkError(method: string, error: any, transaction: any): any {\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\" && error.code === Logger.errors.SERVER_ERROR) {\n        const e = error.error;\n\n        // Etherscan keeps changing their string\n        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {\n            // Etherscan prefixes the data like \"Reverted 0x1234\"\n            let data = e.data;\n            if (data) { data = \"0x\" + data.replace(/^.*0x/i, \"\"); }\n\n            if (isHexString(data)) { return data; }\n\n            logger.throwError(\"missing revert data in call exception\", Logger.errors.CALL_EXCEPTION, {\n                error, data: \"0x\"\n            });\n        }\n    }\n\n    // Get the message from any nested error structure\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR) {\n        if (error.error && typeof(error.error.message) === \"string\") {\n            message = error.error.message;\n        } else if (typeof(error.body) === \"string\") {\n            message = error.body;\n        } else if (typeof(error.responseText) === \"string\") {\n            message = error.responseText;\n        }\n    }\n    message = (message || \"\").toLowerCase();\n\n    // \"Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0\"\n    if (message.match(/insufficient funds/)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n           error, method, transaction\n        });\n    }\n\n    // \"Transaction with the same hash was already imported.\"\n    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n           error, method, transaction\n        });\n    }\n\n    // \"Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce.\"\n    if (message.match(/another transaction with same nonce/)) {\n         logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n         });\n    }\n\n    if (message.match(/execution failed due to an exception|execution reverted/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n\n    throw error;\n}\n\nexport class EtherscanProvider extends BaseProvider{\n    readonly baseUrl: string;\n    readonly apiKey: string;\n\n    constructor(network?: Networkish, apiKey?: string) {\n        super(network);\n\n        defineReadOnly(this, \"baseUrl\", this.getBaseUrl());\n        defineReadOnly(this, \"apiKey\", apiKey || defaultApiKey);\n    }\n\n    getBaseUrl(): string {\n        switch(this.network ? this.network.name: \"invalid\") {\n            case \"homestead\":\n                return \"https:/\\/api.etherscan.io\";\n            case \"ropsten\":\n                return \"https:/\\/api-ropsten.etherscan.io\";\n            case \"rinkeby\":\n                return \"https:/\\/api-rinkeby.etherscan.io\";\n            case \"kovan\":\n                return \"https:/\\/api-kovan.etherscan.io\";\n            case \"goerli\":\n                return \"https:/\\/api-goerli.etherscan.io\";\n            case \"optimism\":\n                return \"https:/\\/api-optimistic.etherscan.io\";\n            default:\n        }\n\n        return logger.throwArgumentError(\"unsupported network\", \"network\", this.network.name);\n    }\n\n    getUrl(module: string, params: Record<string, string>): string {\n        const query = Object.keys(params).reduce((accum, key) => {\n            const value = params[key];\n            if (value != null) {\n                accum += `&${ key }=${ value }`\n            }\n            return accum\n        }, \"\");\n        const apiKey = ((this.apiKey) ? `&apikey=${ this.apiKey }`: \"\");\n        return `${ this.baseUrl }/api?module=${ module }${ query }${ apiKey }`;\n    }\n\n    getPostUrl(): string {\n        return `${ this.baseUrl }/api`;\n    }\n\n    getPostData(module: string, params: Record<string, any>): Record<string, any> {\n        params.module = module;\n        params.apikey = this.apiKey;\n        return params;\n    }\n\n    async fetch(module: string, params: Record<string, any>, post?: boolean): Promise<any> {\n        const url = (post ? this.getPostUrl(): this.getUrl(module, params));\n        const payload = (post ? this.getPostData(module, params): null);\n        const procFunc = (module === \"proxy\") ? getJsonResult: getResult;\n\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: url,\n            provider: this\n        });\n\n        const connection: ConnectionInfo = {\n            url: url,\n            throttleSlotInterval: 1000,\n            throttleCallback: (attempt: number, url: string) => {\n                if (this.isCommunityResource()) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n\n        let payloadStr: string = null;\n        if (payload) {\n            connection.headers = { \"content-type\": \"application/x-www-form-urlencoded; charset=UTF-8\" };\n            payloadStr = Object.keys(payload).map((key) => {\n                return `${ key }=${ payload[key] }`\n            }).join(\"&\");\n        }\n\n        const result = await fetchJson(connection, payloadStr, procFunc || getJsonResult);\n\n        this.emit(\"debug\", {\n            action: \"response\",\n            request: url,\n            response: deepCopy(result),\n            provider: this\n        });\n\n        return result;\n    }\n\n    async detectNetwork(): Promise<Network> {\n        return this.network;\n    }\n\n    async perform(method: string, params: any): Promise<any> {\n\n        switch (method) {\n            case \"getBlockNumber\":\n                return this.fetch(\"proxy\", { action: \"eth_blockNumber\" });\n\n            case \"getGasPrice\":\n                return this.fetch(\"proxy\", { action: \"eth_gasPrice\" });\n\n            case \"getBalance\":\n                // Returns base-10 result\n                return this.fetch(\"account\", {\n                    action: \"balance\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getTransactionCount\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionCount\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getCode\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getCode\",\n                    address: params.address,\n                    tag: params.blockTag\n                });\n\n            case \"getStorageAt\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getStorageAt\",\n                    address: params.address,\n                    position: params.position,\n                    tag: params.blockTag\n                });\n\n            case \"sendTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_sendRawTransaction\",\n                    hex: params.signedTransaction\n                }, true).catch((error) => {\n                    return checkError(\"sendTransaction\", error, params.signedTransaction);\n                });\n\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return this.fetch(\"proxy\", {\n                        action: \"eth_getBlockByNumber\",\n                        tag: params.blockTag,\n                        boolean: (params.includeTransactions ? \"true\": \"false\")\n                    });\n                }\n                throw new Error(\"getBlock by blockHash not implemented\");\n\n            case \"getTransaction\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionByHash\",\n                    txhash: params.transactionHash\n                });\n\n            case \"getTransactionReceipt\":\n                return this.fetch(\"proxy\", {\n                    action: \"eth_getTransactionReceipt\",\n                    txhash: params.transactionHash\n                });\n\n            case \"call\": {\n                if (params.blockTag !== \"latest\") {\n                    throw new Error(\"EtherscanProvider does not support blockTag for call\");\n                }\n\n                const postData = getTransactionPostData(params.transaction);\n                postData.module = \"proxy\";\n                postData.action = \"eth_call\";\n\n                try {\n                    return await this.fetch(\"proxy\", postData, true);\n                } catch (error) {\n                    return checkError(\"call\", error, params.transaction);\n                }\n            }\n\n            case \"estimateGas\": {\n                const postData = getTransactionPostData(params.transaction);\n                postData.module = \"proxy\";\n                postData.action = \"eth_estimateGas\";\n\n                try {\n                    return await this.fetch(\"proxy\", postData, true);\n                } catch (error) {\n                    return checkError(\"estimateGas\", error, params.transaction);\n                }\n            }\n\n            case \"getLogs\": {\n                const args: Record<string, any> = { action: \"getLogs\" }\n\n                if (params.filter.fromBlock) {\n                    args.fromBlock = checkLogTag(params.filter.fromBlock);\n                }\n\n                if (params.filter.toBlock) {\n                    args.toBlock = checkLogTag(params.filter.toBlock);\n                }\n\n                if (params.filter.address) {\n                    args.address = params.filter.address;\n                }\n\n                // @TODO: We can handle slightly more complicated logs using the logs API\n                if (params.filter.topics && params.filter.topics.length > 0) {\n                    if (params.filter.topics.length > 1) {\n                        logger.throwError(\"unsupported topic count\", Logger.errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });\n                    }\n\n                    if (params.filter.topics.length === 1) {\n                        const topic0 = params.filter.topics[0];\n                        if (typeof(topic0) !== \"string\" || topic0.length !== 66) {\n                            logger.throwError(\"unsupported topic format\", Logger.errors.UNSUPPORTED_OPERATION, { topic0: topic0 });\n                        }\n                        args.topic0 = topic0;\n                    }\n                }\n\n                const logs: Array<any> = await this.fetch(\"logs\", args);\n\n                // Cache txHash => blockHash\n                let blocks: { [tag: string]: string } = {};\n\n                // Add any missing blockHash to the logs\n                for (let i = 0; i < logs.length; i++) {\n                    const log = logs[i];\n                    if (log.blockHash != null) { continue; }\n                    if (blocks[log.blockNumber] == null) {\n                        const block = await this.getBlock(log.blockNumber);\n                        if (block) {\n                            blocks[log.blockNumber] = block.hash;\n                        }\n                    }\n                    log.blockHash = blocks[log.blockNumber];\n                }\n\n                return logs;\n            }\n\n            case \"getEtherPrice\":\n                if (this.network.name !== \"homestead\") { return 0.0; }\n                return parseFloat((await this.fetch(\"stats\", { action: \"ethprice\" })).ethusd);\n\n            default:\n                break;\n         }\n\n        return super.perform(method, params);\n    }\n\n    // Note: The `page` page parameter only allows pagination within the\n    //       10,000 window available without a page and offset parameter\n    //       Error: Result window is too large, PageNo x Offset size must\n    //              be less than or equal to 10000\n    async getHistory(addressOrName: string | Promise<string>, startBlock?: BlockTag, endBlock?: BlockTag): Promise<Array<TransactionResponse>> {\n        const params = {\n            action: \"txlist\",\n            address: (await this.resolveName(addressOrName)),\n            startblock: ((startBlock == null) ? 0: startBlock),\n            endblock: ((endBlock == null) ? 99999999: endBlock),\n            sort: \"asc\"\n        };\n\n        const result = await this.fetch(\"account\", params);\n\n        return result.map((tx: any) => {\n            [\"contractAddress\", \"to\"].forEach(function(key) {\n                if (tx[key] == \"\") { delete tx[key]; }\n            });\n            if (tx.creates == null && tx.contractAddress != null) {\n                tx.creates = tx.contractAddress;\n            }\n            const item = this.formatter.transactionResponse(tx);\n            if (tx.timeStamp) { item.timestamp = parseInt(tx.timeStamp); }\n            return item;\n        });\n    }\n\n    isCommunityResource(): boolean {\n        return (this.apiKey === defaultApiKey);\n    }\n}\n","\"use strict\";\n\nimport { Block, BlockWithTransactions, Provider } from \"@ethersproject/abstract-provider\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { Network } from \"@ethersproject/networks\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { poll } from \"@ethersproject/web\";\n\nimport { BaseProvider } from \"./base-provider\";\nimport { isCommunityResource } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction now() { return (new Date()).getTime(); }\n\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks: Array<Network>): Network {\n    let result = null;\n\n    for (let i = 0; i < networks.length; i++) {\n        const network = networks[i];\n\n        // Null! We do not know our network; bail.\n        if (network == null) { return null; }\n\n        if (result) {\n            // Make sure the network matches the previous networks\n            if (!(result.name === network.name && result.chainId === network.chainId &&\n                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\n\n                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n           }\n        } else {\n            result = network;\n        }\n    }\n\n    return result;\n}\n\nfunction median(values: Array<number>, maxDelta?: number): number {\n    values = values.slice().sort();\n    const middle = Math.floor(values.length / 2);\n\n    // Odd length; take the middle\n    if (values.length % 2) {\n        return values[middle];\n    }\n\n    // Even length; take the average of the two middle\n    const a = values[middle - 1], b = values[middle];\n\n    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n        return null;\n    }\n\n    return (a + b) / 2;\n}\n\nfunction serialize(value: any): string {\n    if (value === null) {\n        return \"null\";\n    } else if (typeof(value) === \"number\" || typeof(value) === \"boolean\") {\n        return JSON.stringify(value);\n    } else if (typeof(value) === \"string\") {\n        return value;\n    } else if (BigNumber.isBigNumber(value)) {\n        return value.toString();\n    } else if (Array.isArray(value)) {\n        return JSON.stringify(value.map((i) => serialize(i)));\n    } else if (typeof(value) === \"object\") {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map((key) => {\n            let v = value[key];\n            if (typeof(v) === \"function\") {\n                v = \"[function]\";\n            } else {\n                v = serialize(v);\n            }\n            return JSON.stringify(key) + \":\" + v;\n        }).join(\",\") + \"}\";\n    }\n\n    throw new Error(\"unknown value type: \" + typeof(value));\n}\n\n// Next request ID to use for emitting debug info\nlet nextRid = 1;\n\n\nexport interface FallbackProviderConfig {\n    // The Provider\n    provider: Provider;\n\n    // The priority to favour this Provider; lower values are used first (higher priority)\n    priority?: number;\n\n    // Timeout before also triggering the next provider; this does not stop\n    // this provider and if its result comes back before a quorum is reached\n    // it will be incorporated into the vote\n    // - lower values will cause more network traffic but may result in a\n    //   faster result.\n    stallTimeout?: number;\n\n    // How much this provider contributes to the quorum; sometimes a specific\n    // provider may be more reliable or trustworthy than others, but usually\n    // this should be left as the default\n    weight?: number;\n};\n\n// A Staller is used to provide a delay to give a Provider a chance to response\n// before asking the next Provider to try.\ntype Staller = {\n    wait: (func: () => void) => Promise<void>\n    getPromise: () => Promise<void>,\n    cancel: () => void\n};\n\nfunction stall(duration: number): Staller {\n    let cancel: () => void = null;\n\n    let timer: NodeJS.Timer = null;\n    let promise = <Promise<void>>(new Promise((resolve) => {\n        cancel = function() {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            resolve();\n        }\n        timer = setTimeout(cancel, duration);\n    }));\n\n    const wait = (func: () => void) => {\n        promise = promise.then(func);\n        return promise;\n    }\n\n    function getPromise(): Promise<void> {\n        return promise;\n    }\n\n    return { cancel, getPromise, wait };\n}\n\nconst ForwardErrors = [\n    Logger.errors.CALL_EXCEPTION,\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n    Logger.errors.UNPREDICTABLE_GAS_LIMIT\n];\n\nconst ForwardProperties = [\n    \"address\",\n    \"args\",\n    \"errorArgs\",\n    \"errorSignature\",\n    \"method\",\n    \"transaction\",\n];\n\n\n// @TODO: Make this an object with staller and cancel built-in\ninterface RunningConfig extends FallbackProviderConfig {\n    start?: number;\n    done?: boolean;\n    cancelled?: boolean;\n    runner?: Promise<any>;\n    staller?: Staller;\n    result?: any;\n    error?: Error;\n};\n\nfunction exposeDebugConfig(config: RunningConfig, now?: number): any {\n    const result: any = {\n        weight: config.weight\n    };\n    Object.defineProperty(result, \"provider\", { get: () => config.provider });\n    if (config.start) { result.start = config.start; }\n    if (now) { result.duration = (now - config.start); }\n    if (config.done) {\n        if (config.error) {\n            result.error = config.error;\n        } else {\n            result.result = config.result || null;\n        }\n    }\n    return result;\n}\n\nfunction normalizedTally(normalize: (value: any) => string, quorum: number): (configs: Array<RunningConfig>) => any {\n    return function(configs: Array<RunningConfig>): any {\n\n        // Count the votes for each result\n        const tally: { [ key: string]: { count: number, result: any } } = { };\n        configs.forEach((c) => {\n            const value = normalize(c.result);\n            if (!tally[value]) { tally[value] = { count: 0, result: c.result }; }\n            tally[value].count++;\n        });\n\n        // Check for a quorum on any given result\n        const keys = Object.keys(tally);\n        for (let i = 0; i < keys.length; i++) {\n            const check = tally[keys[i]];\n            if (check.count >= quorum) {\n                return check.result;\n            }\n        }\n\n        // No quroum\n        return undefined;\n    }\n}\nfunction getProcessFunc(provider: FallbackProvider, method: string, params: { [ key: string ]: any }): (configs: Array<RunningConfig>) => any {\n\n    let normalize = serialize;\n\n    switch (method) {\n        case \"getBlockNumber\":\n            // Return the median value, unless there is (median + 1) is also\n            // present, in which case that is probably true and the median\n            // is going to be stale soon. In the event of a malicious node,\n            // the lie will be true soon enough.\n            return function(configs: Array<RunningConfig>): number {\n                const values = configs.map((c) => c.result);\n\n                // Get the median block number\n                let blockNumber = median(configs.map((c) => c.result), 2);\n                if (blockNumber == null) { return undefined; }\n\n                blockNumber = Math.ceil(blockNumber);\n\n                // If the next block height is present, its prolly safe to use\n                if (values.indexOf(blockNumber + 1) >= 0) { blockNumber++; }\n\n                // Don't ever roll back the blockNumber\n                if (blockNumber >= provider._highestBlockNumber) {\n                    provider._highestBlockNumber = blockNumber;\n                }\n\n                return provider._highestBlockNumber;\n            };\n\n        case \"getGasPrice\":\n            // Return the middle (round index up) value, similar to median\n            // but do not average even entries and choose the higher.\n            // Malicious actors must compromise 50% of the nodes to lie.\n            return function(configs: Array<RunningConfig>): BigNumber {\n                const values = configs.map((c) => c.result);\n                values.sort();\n                return values[Math.floor(values.length / 2)];\n            }\n\n        case \"getEtherPrice\":\n            // Returns the median price. Malicious actors must compromise at\n            // least 50% of the nodes to lie (in a meaningful way).\n            return function(configs: Array<RunningConfig>): number {\n                return median(configs.map((c) => c.result));\n            }\n\n        // No additional normalizing required; serialize is enough\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n        case \"getStorageAt\":\n        case \"call\":\n        case \"estimateGas\":\n        case \"getLogs\":\n            break;\n\n        // We drop the confirmations from transactions as it is approximate\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            normalize = function(tx: any): string {\n                if (tx == null) { return null; }\n\n                tx = shallowCopy(tx);\n                tx.confirmations = -1;\n                return serialize(tx);\n            }\n            break;\n\n        // We drop the confirmations from transactions as it is approximate\n        case \"getBlock\":\n            // We drop the confirmations from transactions as it is approximate\n            if (params.includeTransactions) {\n                normalize = function(block: BlockWithTransactions): string {\n                    if (block == null) { return null; }\n\n                    block = shallowCopy(block);\n                    block.transactions = block.transactions.map((tx) => {\n                        tx = shallowCopy(tx);\n                        tx.confirmations = -1;\n                        return tx;\n                    });\n                    return serialize(block);\n                };\n            } else {\n                normalize = function(block: Block): string {\n                    if (block == null) { return null; }\n                    return serialize(block);\n                }\n            }\n            break;\n\n        default:\n            throw new Error(\"unknown method: \" + method);\n    }\n\n    // Return the result if and only if the expected quorum is\n    // satisfied and agreed upon for the final result.\n    return normalizedTally(normalize, provider.quorum);\n\n}\n\n// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nasync function waitForSync(config: RunningConfig, blockNumber: number): Promise<BaseProvider> {\n    const provider = <BaseProvider>(config.provider);\n\n    if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {\n        return provider;\n    }\n\n    return poll(() => {\n        return new Promise((resolve, reject) => {\n            setTimeout(function() {\n\n                // We are synced\n                if (provider.blockNumber >= blockNumber) { return resolve(provider); }\n\n                // We're done; just quit\n                if (config.cancelled) { return resolve(null); }\n\n                // Try again, next block\n                return resolve(undefined);\n            }, 0);\n        });\n    }, { oncePoll: provider });\n}\n\nasync function getRunner(config: RunningConfig, currentBlockNumber: number, method: string, params: { [ key: string]: any }): Promise<any> {\n    let provider = config.provider;\n\n    switch (method) {\n        case \"getBlockNumber\":\n        case \"getGasPrice\":\n            return provider[method]();\n        case \"getEtherPrice\":\n            if ((<any>provider).getEtherPrice) {\n                return (<any>provider).getEtherPrice();\n            }\n            break;\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[method](params.address, params.blockTag || \"latest\");\n        case \"getStorageAt\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\n        case \"getBlock\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[(params.includeTransactions ? \"getBlockWithTransactions\": \"getBlock\")](params.blockTag || params.blockHash);\n        case \"call\":\n        case \"estimateGas\":\n            if (params.blockTag && isHexString(params.blockTag)) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider[method](params.transaction);\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            return provider[method](params.transactionHash);\n        case \"getLogs\": {\n            let filter = params.filter;\n            if ((filter.fromBlock && isHexString(filter.fromBlock)) || (filter.toBlock && isHexString(filter.toBlock))) {\n                provider = await waitForSync(config, currentBlockNumber)\n            }\n            return provider.getLogs(filter);\n        }\n    }\n\n    return logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n        method: method,\n        params: params\n    });\n}\n\nexport class FallbackProvider extends BaseProvider {\n    readonly providerConfigs: ReadonlyArray<FallbackProviderConfig>;\n    readonly quorum: number;\n\n    // Due to the highly asyncronous nature of the blockchain, we need\n    // to make sure we never unroll the blockNumber due to our random\n    // sample of backends\n    _highestBlockNumber: number;\n\n    constructor(providers: Array<Provider | FallbackProviderConfig>, quorum?: number) {\n        if (providers.length === 0) {\n            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n        }\n\n        const providerConfigs: Array<FallbackProviderConfig> = providers.map((configOrProvider, index) => {\n            if (Provider.isProvider(configOrProvider)) {\n                const stallTimeout = isCommunityResource(configOrProvider) ? 2000: 750;\n                const priority = 1;\n                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });\n            }\n\n            const config: FallbackProviderConfig = shallowCopy(configOrProvider);\n\n            if (config.priority == null) { config.priority = 1; }\n            if (config.stallTimeout == null) {\n                config.stallTimeout = isCommunityResource(configOrProvider) ? 2000: 750;\n            }\n            if (config.weight == null) { config.weight = 1; }\n\n            const weight = config.weight;\n            if (weight % 1 || weight > 512 || weight < 1) {\n                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${ index }].weight`, weight);\n            }\n\n            return Object.freeze(config);\n        });\n\n        const total = providerConfigs.reduce((accum, c) => (accum + c.weight), 0);\n\n        if (quorum == null) {\n            quorum = total / 2;\n        } else if (quorum > total) {\n            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n        }\n\n        // Are all providers' networks are known\n        let networkOrReady: Network | Promise<Network> = checkNetworks(providerConfigs.map((c) => (<any>(c.provider)).network));\n\n        // Not all networks are known; we must stall\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then(resolve, reject);\n                }, 0);\n            });\n        }\n\n        super(networkOrReady);\n\n        // Preserve a copy, so we do not get mutated\n        defineReadOnly(this, \"providerConfigs\", Object.freeze(providerConfigs));\n        defineReadOnly(this, \"quorum\", quorum);\n\n        this._highestBlockNumber = -1;\n    }\n\n    async detectNetwork(): Promise<Network> {\n        const networks = await Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));\n        return checkNetworks(networks);\n    }\n\n    async perform(method: string, params: { [name: string]: any }): Promise<any> {\n        // Sending transactions is special; always broadcast it to all backends\n        if (method === \"sendTransaction\") {\n            const results: Array<string | Error> = await Promise.all(this.providerConfigs.map((c) => {\n                return c.provider.sendTransaction(params.signedTransaction).then((result) => {\n                    return result.hash;\n                }, (error) => {\n                    return error;\n                });\n            }));\n\n            // Any success is good enough (other errors are likely \"already seen\" errors\n            for (let i = 0; i < results.length; i++) {\n                const result = results[i];\n                if (typeof(result) === \"string\") { return result; }\n            }\n\n            // They were all an error; pick the first error\n            throw results[0];\n        }\n\n        // We need to make sure we are in sync with our backends, so we need\n        // to know this before we can make a lot of calls\n        if (this._highestBlockNumber === -1 && method !== \"getBlockNumber\") {\n            await this.getBlockNumber();\n        }\n\n        const processFunc = getProcessFunc(this, method, params);\n\n        // Shuffle the providers and then sort them by their priority; we\n        // shallowCopy them since we will store the result in them too\n        const configs: Array<RunningConfig> = shuffled(this.providerConfigs.map(shallowCopy));\n        configs.sort((a, b) => (a.priority - b.priority));\n\n        const currentBlockNumber = this._highestBlockNumber;\n\n        let i = 0;\n        let first = true;\n        while (true) {\n            const t0 = now();\n\n            // Compute the inflight weight (exclude anything past)\n            let inflightWeight = configs.filter((c) => (c.runner && ((t0 - c.start) < c.stallTimeout)))\n                                        .reduce((accum, c) => (accum + c.weight), 0);\n\n            // Start running enough to meet quorum\n            while (inflightWeight < this.quorum && i < configs.length) {\n                const config = configs[i++];\n\n                const rid = nextRid++;\n\n                config.start = now();\n                config.staller = stall(config.stallTimeout);\n                config.staller.wait(() => { config.staller = null; });\n\n                config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {\n                    config.done = true;\n                    config.result = result;\n\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, now()),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                     }\n\n                }, (error) => {\n                    config.done = true;\n                    config.error = error;\n\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, now()),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                    }\n                });\n\n                if (this.listenerCount(\"debug\")) {\n                    this.emit(\"debug\", {\n                        action: \"request\",\n                        rid: rid,\n                        backend: exposeDebugConfig(config, null),\n                        request: { method: method, params: deepCopy(params) },\n                        provider: this\n                    });\n                }\n\n                inflightWeight += config.weight;\n            }\n\n            // Wait for anything meaningful to finish or stall out\n            const waiting: Array<Promise<any>> = [ ];\n            configs.forEach((c) => {\n                if (c.done || !c.runner) { return; }\n                waiting.push(c.runner);\n                if (c.staller) { waiting.push(c.staller.getPromise()); }\n            });\n\n            if (waiting.length) { await Promise.race(waiting); }\n\n            // Check the quorum and process the results; the process function\n            // may additionally decide the quorum is not met\n            const results = configs.filter((c) => (c.done && c.error == null));\n            if (results.length >= this.quorum) {\n                const result = processFunc(results);\n                if (result !== undefined) {\n                    // Shut down any stallers\n                    configs.forEach(c => {\n                        if (c.staller) { c.staller.cancel(); }\n                        c.cancelled = true;\n                    });\n                    return result;\n                }\n                if (!first) { await stall(100).getPromise(); }\n                first = false;\n            }\n\n            // No result, check for errors that should be forwarded\n            const errors = configs.reduce((accum, c) => {\n                if (!c.done || c.error == null) { return accum; }\n\n                const code = (<any>(c.error)).code;\n                if (ForwardErrors.indexOf(code) >= 0) {\n                    if (!accum[code]) { accum[code] = { error: c.error, weight: 0 }; }\n                    accum[code].weight += c.weight;\n                }\n\n                return accum;\n            }, <{ [ code: string ]: { error: Error, weight: number } }>({ }));\n\n            Object.keys(errors).forEach((errorCode: string) => {\n                const tally = errors[errorCode];\n                if (tally.weight < this.quorum) { return; }\n\n                // Shut down any stallers\n                configs.forEach(c => {\n                    if (c.staller) { c.staller.cancel(); }\n                    c.cancelled = true;\n                });\n\n                const e = <any>(tally.error);\n\n                const props: { [ name: string ]: any } = { };\n                ForwardProperties.forEach((name) => {\n                    if (e[name] == null) { return; }\n                    props[name] = e[name];\n                });\n\n                logger.throwError(e.reason || e.message, <any>errorCode, props);\n            });\n\n            // All configs have run to completion; we will never get more data\n            if (configs.filter((c) => !c.done).length === 0) { break; }\n        }\n\n        // Shut down any stallers; shouldn't be any\n        configs.forEach(c => {\n            if (c.staller) { c.staller.cancel(); }\n            c.cancelled = true;\n        });\n\n        return logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n            method: method,\n            params: params,\n            //results: configs.map((c) => c.result),\n            //errors: configs.map((c) => c.error),\n            results: configs.map((c) => exposeDebugConfig(c)),\n            provider: this\n        });\n    }\n}\n","\"use strict\";\n\nconst IpcProvider: any = null;\n\nexport {\n    IpcProvider\n};\n","\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { CommunityResourcable, showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n\nconst defaultProjectId = \"84842078b09946638c03157f83405213\"\n\nexport class InfuraWebSocketProvider extends WebSocketProvider implements CommunityResourcable {\n    readonly apiKey: string;\n    readonly projectId: string;\n    readonly projectSecret: string;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        const provider = new InfuraProvider(network, apiKey);\n        const connection = provider.connection;\n        if (connection.password) {\n            logger.throwError(\"INFURA WebSocket project secrets unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"InfuraProvider.getWebSocketProvider()\"\n            });\n        }\n\n        const url = connection.url.replace(/^http/i, \"ws\").replace(\"/v3/\", \"/ws/v3/\");\n        super(url, network);\n\n        defineReadOnly(this, \"apiKey\", provider.projectId);\n        defineReadOnly(this, \"projectId\", provider.projectId);\n        defineReadOnly(this, \"projectSecret\", provider.projectSecret);\n    }\n\n    isCommunityResource(): boolean {\n        return (this.projectId === defaultProjectId);\n    }\n}\n\nexport class InfuraProvider extends UrlJsonRpcProvider {\n    readonly projectId: string;\n    readonly projectSecret: string;\n\n    static getWebSocketProvider(network?: Networkish, apiKey?: any): InfuraWebSocketProvider {\n        return new InfuraWebSocketProvider(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        const apiKeyObj: { apiKey: string, projectId: string, projectSecret: string } = {\n            apiKey: defaultProjectId,\n            projectId: defaultProjectId,\n            projectSecret: null\n        };\n\n        if (apiKey == null) { return apiKeyObj; }\n\n        if (typeof(apiKey) === \"string\") {\n            apiKeyObj.projectId = apiKey;\n\n        } else if (apiKey.projectSecret != null) {\n            logger.assertArgument((typeof(apiKey.projectId) === \"string\"),\n                \"projectSecret requires a projectId\", \"projectId\", apiKey.projectId);\n            logger.assertArgument((typeof(apiKey.projectSecret) === \"string\"),\n                \"invalid projectSecret\", \"projectSecret\", \"[REDACTED]\");\n\n            apiKeyObj.projectId = apiKey.projectId;\n            apiKeyObj.projectSecret = apiKey.projectSecret;\n\n        } else if (apiKey.projectId) {\n            apiKeyObj.projectId = apiKey.projectId;\n        }\n\n        apiKeyObj.apiKey = apiKeyObj.projectId;\n\n        return apiKeyObj;\n    }\n\n    static getUrl(network: Network, apiKey: any): ConnectionInfo {\n        let host: string = null;\n        switch(network ? network.name: \"unknown\") {\n            case \"homestead\":\n                host = \"mainnet.infura.io\";\n                break;\n            case \"ropsten\":\n                host = \"ropsten.infura.io\";\n                break;\n            case \"rinkeby\":\n                host = \"rinkeby.infura.io\";\n                break;\n            case \"kovan\":\n                host = \"kovan.infura.io\";\n                break;\n            case \"goerli\":\n                host = \"goerli.infura.io\";\n                break;\n            case \"matic\":\n                host = \"polygon-mainnet.infura.io\";\n                break;\n            case \"maticmum\":\n                host = \"polygon-mumbai.infura.io\";\n                break;\n            case \"optimism\":\n                host = \"optimism-mainnet.infura.io\";\n                break;\n            case \"optimism-kovan\":\n                host = \"optimism-kovan.infura.io\";\n                break;\n            case \"arbitrum\":\n                host = \"arbitrum-mainnet.infura.io\";\n                break;\n            case \"arbitrum-rinkeby\":\n                host = \"arbitrum-rinkeby.infura.io\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n\n        const connection: ConnectionInfo = {\n            allowGzip: true,\n            url: (\"https:/\" + \"/\" + host + \"/v3/\" + apiKey.projectId),\n            throttleCallback: (attempt: number, url: string) => {\n                if (apiKey.projectId === defaultProjectId) {\n                    showThrottleMessage();\n                }\n                return Promise.resolve(true);\n            }\n        };\n\n        if (apiKey.projectSecret != null) {\n            connection.user = \"\";\n            connection.password = apiKey.projectSecret\n        }\n\n        return connection;\n    }\n\n    isCommunityResource(): boolean {\n        return (this.projectId === defaultProjectId);\n    }\n}\n","\nimport { deepCopy } from \"@ethersproject/properties\";\nimport { fetchJson } from \"@ethersproject/web\";\n\nimport { JsonRpcProvider } from \"./json-rpc-provider\";\n\n// Experimental\n\nexport class JsonRpcBatchProvider extends JsonRpcProvider {\n    _pendingBatchAggregator: NodeJS.Timer;\n    _pendingBatch: Array<{\n        request: { method: string, params: Array<any>, id: number, jsonrpc: \"2.0\" },\n        resolve: (result: any) => void,\n        reject: (error: Error) => void\n    }>;\n\n    send(method: string, params: Array<any>): Promise<any> {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n\n        if (this._pendingBatch == null) {\n            this._pendingBatch = [ ];\n        }\n\n        const inflightRequest: any = { request, resolve: null, reject: null };\n\n        const promise = new Promise((resolve, reject) => {\n            inflightRequest.resolve = resolve;\n            inflightRequest.reject = reject;\n        });\n\n        this._pendingBatch.push(inflightRequest);\n\n        if (!this._pendingBatchAggregator) {\n            // Schedule batch for next event loop + short duration\n            this._pendingBatchAggregator = setTimeout(() => {\n\n                // Get teh current batch and clear it, so new requests\n                // go into the next batch\n                const batch = this._pendingBatch;\n                this._pendingBatch = null;\n                this._pendingBatchAggregator = null;\n\n                // Get the request as an array of requests\n                const request = batch.map((inflight) => inflight.request);\n\n                this.emit(\"debug\", {\n                    action: \"requestBatch\",\n                    request: deepCopy(request),\n                    provider: this\n                });\n\n                return fetchJson(this.connection, JSON.stringify(request)).then((result) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        request: request,\n                        response: result,\n                        provider: this\n                    });\n\n                    // For each result, feed it to the correct Promise, depending\n                    // on whether it was a success or error\n                    batch.forEach((inflightRequest, index) => {\n                        const payload = result[index];\n                        if (payload.error) {\n                            const error = new Error(payload.error.message);\n                            (<any>error).code = payload.error.code;\n                            (<any>error).data = payload.error.data;\n                            inflightRequest.reject(error);\n                        } else {\n                            inflightRequest.resolve(payload.result);\n                        }\n                    });\n\n                }, (error) => {\n                    this.emit(\"debug\", {\n                        action: \"response\",\n                        error: error,\n                        request: request,\n                        provider: this\n                    });\n\n                    batch.forEach((inflightRequest) => {\n                        inflightRequest.reject(error);\n                    });\n                });\n\n            }, 10);\n        }\n\n        return promise;\n    }\n}\n","/* istanbul ignore file */\n\n\"use strict\";\n\nimport { Network } from \"@ethersproject/networks\";\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n// Special API key provided by Nodesmith for ethers.js\nconst defaultApiKey = \"ETHERS_JS_SHARED\";\n\nexport class NodesmithProvider extends UrlJsonRpcProvider {\n\n    static getApiKey(apiKey: any): any {\n        if (apiKey && typeof(apiKey) !== \"string\") {\n            logger.throwArgumentError(\"invalid apiKey\", \"apiKey\", apiKey);\n        }\n        return apiKey || defaultApiKey;\n    }\n\n    static getUrl(network: Network, apiKey?: any): string {\n        logger.warn(\"NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.\");\n\n        let host = null;\n        switch (network.name) {\n            case \"homestead\":\n                host = \"https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc\";\n                break;\n            case \"ropsten\":\n                host = \"https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc\";\n                break;\n            case \"rinkeby\":\n                host = \"https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc\";\n                break;\n            case \"goerli\":\n                host = \"https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc\";\n                break;\n            case \"kovan\":\n                host = \"https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc\";\n                break;\n            default:\n               logger.throwArgumentError(\"unsupported network\", \"network\", arguments[0]);\n        }\n\n        return (host + \"?apiKey=\" + apiKey);\n    }\n}\n","\"use strict\";\n\nimport { Network, Networkish } from \"@ethersproject/networks\";\nimport { getStatic } from \"@ethersproject/properties\";\nimport { ConnectionInfo } from \"@ethersproject/web\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nimport { UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\n\n// These are load-balancer-based application IDs\nconst defaultApplicationIds: Record<string, string> = {\n    homestead: \"6004bcd10040261633ade990\",\n    ropsten: \"6004bd4d0040261633ade991\",\n    rinkeby: \"6004bda20040261633ade994\",\n    goerli: \"6004bd860040261633ade992\",\n};\n\nexport class PocketProvider extends UrlJsonRpcProvider {\n    readonly applicationId: string;\n    readonly applicationSecretKey: string;\n    readonly loadBalancer: boolean;\n\n    constructor(network?: Networkish, apiKey?: any) {\n        // We need a bit of creativity in the constructor because\n        // Pocket uses different default API keys based on the network\n\n        if (apiKey == null) {\n            const n = getStatic<(network: Networkish) => Network>(new.target, \"getNetwork\")(network);\n            if (n) {\n                const applicationId = defaultApplicationIds[n.name];\n                if (applicationId) {\n                    apiKey = {\n                        applicationId: applicationId,\n                        loadBalancer: true\n                    };\n                }\n            }\n\n            // If there was any issue above, we don't know this network\n            if (apiKey == null) {\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n            }\n\n        }\n\n        super(network, apiKey);\n    }\n\n    static getApiKey(apiKey: any): any {\n        // Most API Providers allow null to get the default configuration, but\n        // Pocket requires the network to decide the default provider, so we\n        // rely on hijacking the constructor to add a sensible default for us\n\n        if (apiKey == null) {\n            logger.throwArgumentError(\"PocketProvider.getApiKey does not support null apiKey\", \"apiKey\", apiKey);\n        }\n\n        const apiKeyObj: { applicationId: string, applicationSecretKey: string, loadBalancer: boolean } = {\n            applicationId: null,\n            loadBalancer: false,\n            applicationSecretKey: null\n        };\n\n        // Parse applicationId and applicationSecretKey\n        if (typeof (apiKey) === \"string\") {\n            apiKeyObj.applicationId = apiKey;\n\n        } else if (apiKey.applicationSecretKey != null) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"),\n                \"applicationSecretKey requires an applicationId\", \"applicationId\", apiKey.applicationId);\n            logger.assertArgument((typeof (apiKey.applicationSecretKey) === \"string\"),\n                \"invalid applicationSecretKey\", \"applicationSecretKey\", \"[REDACTED]\");\n\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n\n        } else if (apiKey.applicationId) {\n            logger.assertArgument((typeof (apiKey.applicationId) === \"string\"),\n                \"apiKey.applicationId must be a string\", \"apiKey.applicationId\", apiKey.applicationId);\n\n            apiKeyObj.applicationId = apiKey.applicationId;\n            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;\n\n        } else {\n            logger.throwArgumentError(\"unsupported PocketProvider apiKey\", \"apiKey\", apiKey);\n        }\n\n        return apiKeyObj;\n    }\n\n    static getUrl(network: Network, apiKey: any): ConnectionInfo {\n        let host: string = null;\n        switch (network ? network.name : \"unknown\") {\n            case \"homestead\":\n                host = \"eth-mainnet.gateway.pokt.network\";\n                break;\n            case \"ropsten\":\n                host = \"eth-ropsten.gateway.pokt.network\";\n                break;\n            case \"rinkeby\":\n                host = \"eth-rinkeby.gateway.pokt.network\";\n                break;\n            case \"goerli\":\n                host = \"eth-goerli.gateway.pokt.network\";\n                break;\n            default:\n                logger.throwError(\"unsupported network\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"network\",\n                    value: network\n                });\n        }\n\n        let url = null;\n        if (apiKey.loadBalancer) {\n            url = `https:/\\/${ host }/v1/lb/${ apiKey.applicationId }`\n        } else {\n            url = `https:/\\/${ host }/v1/${ apiKey.applicationId }`\n        }\n\n        const connection: ConnectionInfo = { url };\n\n        // Initialize empty headers\n        connection.headers = {}\n\n        // Apply application secret key\n        if (apiKey.applicationSecretKey != null) {\n            connection.user = \"\";\n            connection.password = apiKey.applicationSecretKey\n        }\n\n        return connection;\n    }\n\n    isCommunityResource(): boolean {\n        return (this.applicationId === defaultApplicationIds[this.network.name]);\n    }\n}\n","\"use strict\";\n\nimport {\n    Block,\n    BlockTag,\n    EventType,\n    FeeData,\n    Filter,\n    Log,\n    Listener,\n    Provider,\n    TransactionReceipt,\n    TransactionRequest,\n    TransactionResponse\n} from \"@ethersproject/abstract-provider\";\n\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { Network, Networkish } from \"@ethersproject/networks\";\n\nimport { BaseProvider, EnsProvider, EnsResolver, Resolver } from \"./base-provider\";\n\nimport { AlchemyProvider, AlchemyWebSocketProvider } from \"./alchemy-provider\";\nimport { AnkrProvider } from \"./ankr-provider\";\nimport { CloudflareProvider } from \"./cloudflare-provider\";\nimport { EtherscanProvider } from \"./etherscan-provider\";\nimport { FallbackProvider, FallbackProviderConfig } from \"./fallback-provider\";\nimport { IpcProvider } from \"./ipc-provider\";\nimport { InfuraProvider, InfuraWebSocketProvider } from \"./infura-provider\";\nimport { JsonRpcProvider, JsonRpcSigner } from \"./json-rpc-provider\";\nimport { JsonRpcBatchProvider } from \"./json-rpc-batch-provider\";\nimport { NodesmithProvider } from \"./nodesmith-provider\";\nimport { PocketProvider } from \"./pocket-provider\";\nimport { StaticJsonRpcProvider, UrlJsonRpcProvider } from \"./url-json-rpc-provider\";\nimport { Web3Provider } from \"./web3-provider\";\nimport { WebSocketProvider } from \"./websocket-provider\";\nimport { ExternalProvider, JsonRpcFetchFunc } from \"./web3-provider\";\n\nimport { CommunityResourcable, Formatter, isCommunityResourcable, isCommunityResource, showThrottleMessage } from \"./formatter\";\n\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\n////////////////////////\n// Helper Functions\n\nfunction getDefaultProvider(network?: Networkish, options?: any): BaseProvider {\n    if (network == null) { network = \"homestead\"; }\n\n    // If passed a URL, figure out the right type of provider based on the scheme\n    if (typeof(network) === \"string\") {\n        // @TODO: Add support for IpcProvider; maybe if it ends in \".ipc\"?\n\n        // Handle http and ws (and their secure variants)\n        const match = network.match(/^(ws|http)s?:/i);\n        if (match) {\n            switch (match[1].toLowerCase()) {\n                case \"http\": case \"https\":\n                    return new JsonRpcProvider(network);\n                case \"ws\": case \"wss\":\n                    return new WebSocketProvider(network);\n                default:\n                    logger.throwArgumentError(\"unsupported URL scheme\", \"network\", network);\n            }\n        }\n    }\n\n    const n = getNetwork(network);\n    if (!n || !n._defaultProvider) {\n        logger.throwError(\"unsupported getDefaultProvider network\", Logger.errors.NETWORK_ERROR, {\n            operation: \"getDefaultProvider\",\n            network: network\n        });\n    }\n\n    return n._defaultProvider({\n        FallbackProvider,\n\n        AlchemyProvider,\n        AnkrProvider,\n        CloudflareProvider,\n        EtherscanProvider,\n        InfuraProvider,\n        JsonRpcProvider,\n        NodesmithProvider,\n        PocketProvider,\n        Web3Provider,\n\n        IpcProvider,\n    }, options);\n}\n\n////////////////////////\n// Exports\n\nexport {\n\n    // Abstract Providers (or Abstract-ish)\n    Provider,\n    BaseProvider,\n\n    Resolver,\n\n    UrlJsonRpcProvider,\n\n    ///////////////////////\n    // Concrete Providers\n\n    FallbackProvider,\n\n    AlchemyProvider,\n    AlchemyWebSocketProvider,\n    AnkrProvider,\n    CloudflareProvider,\n    EtherscanProvider,\n    InfuraProvider,\n    InfuraWebSocketProvider,\n    JsonRpcProvider,\n    JsonRpcBatchProvider,\n    NodesmithProvider,\n    PocketProvider,\n    StaticJsonRpcProvider,\n    Web3Provider,\n    WebSocketProvider,\n\n    IpcProvider,\n\n\n    ///////////////////////\n    // Signer\n\n    JsonRpcSigner,\n\n\n    ///////////////////////\n    // Functions\n\n    getDefaultProvider,\n    getNetwork,\n    isCommunityResource,\n    isCommunityResourcable,\n    showThrottleMessage,\n\n\n    ///////////////////////\n    // Objects\n\n    Formatter,\n\n\n    ///////////////////////\n    // Types\n\n    Block,\n    BlockTag,\n    EventType,\n    FeeData,\n    Filter,\n    Log,\n    Listener,\n    TransactionReceipt,\n    TransactionRequest,\n    TransactionResponse,\n\n    ExternalProvider,\n    JsonRpcFetchFunc,\n\n    FallbackProviderConfig,\n\n    Network,\n    Networkish,\n\n    EnsProvider,\n    EnsResolver,\n\n    CommunityResourcable\n};\n\n"],"names":["logger","Logger","version","defaultApiKey","AlchemyWebSocketProvider","network","apiKey","provider","AlchemyProvider","url","connection","replace","defineReadOnly","this","WebSocketProvider","throwArgumentError","host","name","arguments","allowGzip","throttleCallback","attempt","showThrottleMessage","Promise","resolve","UrlJsonRpcProvider","getHost","AnkrProvider","projectSecret","user","password","CloudflareProvider","method","params","_super","perform","call","blockTag","block","number","getTransactionPostData","transaction","result","key","value","type","gasLimit","gasPrice","maxFeePerGs","maxPriorityFeePerGas","nonce","hexValue","hexlify","accessListify","map","set","address","storageKeys","join","getResult","status","message","error","Error","JSON","stringify","toLowerCase","indexOf","throttleRetry","getJsonResult","jsonrpc","code","data","checkLogTag","parseInt","substring","checkError","e","match","isHexString","throwError","body","responseText","EtherscanProvider","getBaseUrl","module","query","Object","keys","reduce","accum","baseUrl","apikey","post","getPostUrl","getUrl","payload","getPostData","procFunc","emit","action","request","throttleSlotInterval","isCommunityResource","payloadStr","headers","fetchJson","response","deepCopy","fetch","tag","position","hex","signedTransaction","catch","boolean","includeTransactions","txhash","transactionHash","postData","args","filter","fromBlock","toBlock","topics","length","topic0","logs","blocks","i","log","blockHash","blockNumber","getBlock","hash","parseFloat","ethusd","addressOrName","startBlock","endBlock","resolveName","startblock","endblock","sort","tx","forEach","creates","contractAddress","item","formatter","transactionResponse","timeStamp","timestamp","BaseProvider","now","Date","getTime","checkNetworks","networks","chainId","ensAddress","median","values","maxDelta","slice","middle","Math","floor","a","b","abs","serialize","BigNumber","toString","Array","isArray","v","nextRid","stall","duration","cancel","timer","promise","clearTimeout","setTimeout","getPromise","wait","func","then","ForwardErrors","ForwardProperties","exposeDebugConfig","config","weight","defineProperty","get","start","done","getProcessFunc","normalize","configs","c","ceil","_highestBlockNumber","shallowCopy","confirmations","transactions","quorum","tally","count","check","normalizedTally","waitForSync","poll","reject","cancelled","undefined","oncePoll","getRunner","currentBlockNumber","getEtherPrice","getStorageAt","getLogs","FallbackProvider","providers","providerConfigs","configOrProvider","index","Provider","stallTimeout","freeze","priority","total","networkOrReady","detectNetwork","all","getNetwork","sendTransaction","results","getBlockNumber","processFunc","shuffled","first","t0","inflightWeight","runner","rid","staller","listenerCount","backend","waiting","push","race","errors","errorCode","props","reason","IpcProvider","defaultProjectId","InfuraWebSocketProvider","InfuraProvider","operation","projectId","apiKeyObj","assertArgument","argument","JsonRpcBatchProvider","id","_nextId","_pendingBatch","inflightRequest","_pendingBatchAggregator","batch","inflight","JsonRpcProvider","NodesmithProvider","warn","defaultApplicationIds","homestead","ropsten","rinkeby","goerli","PocketProvider","n","getStatic","applicationId","loadBalancer","applicationSecretKey","getDefaultProvider","options","_defaultProvider","Web3Provider"],"sourceRoot":""}